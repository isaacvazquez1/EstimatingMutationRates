---
title: "Least squares estimation"
output: pdf_document
---

```{r}
h <- function(z) {
  (1 - z)^((1 - z) / z)
}

px <- function(z,Am,m1,Amm) {
  (h(z)^Am) * (h(h(z)^m1)^Amm)
}

psb <- function(z,pb) {
  (1 - pb) + pb * z
}

ps <- function(z,p) {
  (1 - p) + p * z
}

pgb <- function(z,Am,m1,pb,Amm) {
  px(psb(z,pb),Am,m1,Amm)
}

pgs <- function(z,p,Am,m1,Amm){
  px(ps(z,p),Am,m1,Amm)
}


FILENAME <- "luria_4trans_1.00e-007mua_2seed.txt"
td <- read.table(FILENAME,header = F,sep="")
#Old instruction
#as.matrix(read.csv(FILENAME, header = F, sep = " "))
head(td)
pb1 <- 2^(20)/(2^(33))
ps1 <- 0.0000005
epgf_gc_j<-function(j){
  a=c()
  for (i in 1:nrow(td)){
    a=c(a,rbinom(n = 1, size = (td[, (4 * (j - 1) + 2)]+td[ ,(4 * (j - 1) + 4)])[i], prob = ps1))
  }
  epgf<-function(x){
    return(sum(x^a)/nrow(td))
  }
  return(epgf)
}
zr <- seq(0.4, 0.9, by = 0.1)
nn1 <- 2^(33)
ni <- 30
lbm <- 10^(-9)
ubm <- 10^(-5)
mr <- (lbm * (ubm / lbm)^(0:ni / ni)) * nn1
lbm1 <- 10^(-8)
ubm1 <- 10^(-4)
m1r <- (lbm1 * (ubm1 / lbm1)^(0:ni / ni))
lbmm <- 10^(-8)
ubmm <- 10^(-4)
mmr <- (lbmm * (ubmm / lbmm)^(0:ni / ni)) * nn1



tls1 <- list()
tls2 <- list()
tls3 <- list()
lls <- list()

epgf1 <- epgf_gc_j(1)
epgf2 <- epgf_gc_j(2)
epgf3 <- epgf_gc_j(3)
tls <- list()
mne1 <- 1000000
mne2 <- 1000000
mne3 <- 1000000
for (mi in mr) {
  for (m1i in m1r) {
    for (mmi in mmr) {
      tp1=0
      tp2=0
      tp3=0
      for(z in zr){
        #pgs(z,p,Am,m1,Amm)             #Parameters to be used
        pg1 <- pgs(z,ps1,mi,m1i,mmi)  
        #pgb(z,Am,m1,pb,Amm)            #Parameters to be used
        pg2 <- pgb(pg1,mi,m1i,pb1,mmi)  
        
        pg3 <- pgb(pg2,mi,m1i,pb1,mmi)
        
        tp1=tp1+(pg1 - epgf1(z))^2
        tp2=tp2+(pg2 - epgf2(z))^2
        tp3=tp3+(pg3 - epgf3(z))^2
      }
      tpt1 <- tp1
      tpt2 <- tp1 + tp2
      tpt3 <- tp1 + tp2 + tp3
      if (tpt1 < mne1) {
        mne1 <- tpt1
        ls1 <- list(log(mi / nn1), log(m1i), log(mmi / nn1), log(tpt1))
      }
      if (tpt2 < mne2) {
        mne2 <- tpt2
        ls2 <- list(log(mi / nn1), log(m1i), log(mmi / nn1), log(tpt2))
      }
      if (tpt3 < mne3) {
        mne3 <- tpt3
        ls3 <- list(log(mi / nn1), log(m1i), log(mmi / nn1), log(tpt3))
      }
      tls <- c(tls, list(list(log(mi / nn1), log(m1i), log(mmi / nn1)),
                         list(log(tpt1), log(tpt2), log(tpt3))))
    }
  }
}
tls1 <- c(tls1, list(ls1))
tls2 <- c(tls2, list(ls2))
tls3 <- c(tls3, list(ls3))
lls <- c(lls, list(tls))


mre<-c(mean(sapply(tls3, `[[`, 1)),mean(sapply(tls3, `[[`,2)),mean(sapply(tls3, `[[`, 3)))
exp(mre)

```
```{r}
library(parallel)
#Use 20 cores only
cl <- makeCluster(detectCores() - 5)
cl

library(doParallel)
registerDoParallel(cl)

estimation<-function(FILENAME){
  
h <- function(z) {
  (1 - z)^((1 - z) / z)
}

px <- function(z,Am,m1,Amm) {
  (h(z)^Am) * (h(h(z)^m1)^Amm)
}

psb <- function(z,pb) {
  (1 - pb) + pb * z
}

ps <- function(z,p) {
  (1 - p) + p * z
}

pgb <- function(z,Am,m1,pb,Amm) {
  px(psb(z,pb),Am,m1,Amm)
}

pgs <- function(z,p,Am,m1,Amm){
  px(ps(z,p),Am,m1,Amm)
}


td <- read.table(FILENAME,header = F,sep="")
#Old instruction
#as.matrix(read.csv(FILENAME, header = F, sep = " "))
head(td)
pb1 <- 2^(20)/(2^(33))
ps1 <- 0.0000005
epgf_gc_j<-function(j){
  a=c()
  for (i in 1:nrow(td)){
    a=c(a,rbinom(n = 1, size = (td[, (4 * (j - 1) + 2)]+td[ ,(4 * (j - 1) + 4)])[i], prob = ps1))
  }
  epgf<-function(x){
    return(sum(x^a)/nrow(td))
  }
  return(epgf)
}
zr <- seq(0.4, 0.9, by = 0.1)
nn1 <- 2^(33)
ni <- 30
lbm <- 10^(-9)
ubm <- 10^(-5)
mr <- (lbm * (ubm / lbm)^(0:ni / ni)) * nn1
lbm1 <- 10^(-8)
ubm1 <- 10^(-4)
m1r <- (lbm1 * (ubm1 / lbm1)^(0:ni / ni))
lbmm <- 10^(-8)
ubmm <- 10^(-4)
mmr <- (lbmm * (ubmm / lbmm)^(0:ni / ni)) * nn1



tls1 <- list()
tls2 <- list()
tls3 <- list()
lls <- list()

epgf1 <- epgf_gc_j(1)
epgf2 <- epgf_gc_j(2)
epgf3 <- epgf_gc_j(3)
tls <- list()
mne1 <- 1000000
mne2 <- 1000000
mne3 <- 1000000
for (mi in mr) {
  for (m1i in m1r) {
    for (mmi in mmr) {
      tp1=0
      tp2=0
      tp3=0
      for(z in zr){
        #pgs(z,p,Am,m1,Amm)             #Parameters to be used
        pg1 <- pgs(z,ps1,mi,m1i,mmi)  
        #pgb(z,Am,m1,pb,Amm)            #Parameters to be used
        pg2 <- pgb(pg1,mi,m1i,pb1,mmi)  
        
        pg3 <- pgb(pg2,mi,m1i,pb1,mmi)
        
        tp1=tp1+(pg1 - epgf1(z))^2
        tp2=tp2+(pg2 - epgf2(z))^2
        tp3=tp3+(pg3 - epgf3(z))^2
      }
      tpt1 <- tp1
      tpt2 <- tp1 + tp2
      tpt3 <- tp1 + tp2 + tp3
      if (tpt1 < mne1) {
        mne1 <- tpt1
        ls1 <- list(log(mi / nn1), log(m1i), log(mmi / nn1), log(tpt1))
      }
      if (tpt2 < mne2) {
        mne2 <- tpt2
        ls2 <- list(log(mi / nn1), log(m1i), log(mmi / nn1), log(tpt2))
      }
      if (tpt3 < mne3) {
        mne3 <- tpt3
        ls3 <- list(log(mi / nn1), log(m1i), log(mmi / nn1), log(tpt3))
      }
      tls <- c(tls, list(list(log(mi / nn1), log(m1i), log(mmi / nn1)),
                         list(log(tpt1), log(tpt2), log(tpt3))))
    }
  }
}
tls1 <- c(tls1, list(ls1))
tls2 <- c(tls2, list(ls2))
tls3 <- c(tls3, list(ls3))
lls <- c(lls, list(tls))

aux<-list(tls1,tls2,tls3)


aux1=sapply(aux, `[[`, 1)
GC_1=as.numeric(aux1[,1])
GC_2=as.numeric(aux1[,2])
GC_3=as.numeric(aux1[,3])
result<-list(GC_1,GC_2,GC_3)
return(result)

}


rep=125

res_GC_1=c()
res_GC_2=c()
res_GC_3=c()
ti=Sys.time()
result<-foreach(k=1:rep)%dopar%{
    estimation(FILENAME = FILENAME)
}

for(j in 1:rep){
    aux=result[[j]]
    res_GC_1=rbind(res_GC_1,aux[[1]])
    res_GC_2=rbind(res_GC_1,aux[[2]])
    res_GC_3=rbind(res_GC_1,aux[[3]])
  }

estimations_GC_1=exp(colMeans(res_GC_1[,1:3]))
estimations_GC_2=exp(colMeans(res_GC_2[,1:3]))
estimations_GC_3=exp(colMeans(res_GC_3[,1:3]))

names(estimations_GC_1)<-c('WT2R','WT2M','M2R')
names(estimations_GC_2)<-c('WT2R','WT2M','M2R')
names(estimations_GC_3)<-c('WT2R','WT2M','M2R')

estimations_GC_1
estimations_GC_2
estimations_GC_3

tf=Sys.time()

ti
tf
```
